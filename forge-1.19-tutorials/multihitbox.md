# Multi-Hitbox Entities

> WARNING: this has not been reviewed for 1.19 but i suspect little has changed

Vanilla minecraft only allows hitboxes to be square based rectangular prisms (you can only define the height and the width). The only place vanilla needs to get around this restriction is for the ender dragon. This is done by creating many sub-entities that follow the movement of the parent entity and pass on any damage delt to the parent. 

In the ender dragon's implimentation, the entities do not have a registered `EntityType` and are never explicitly added to the world. There are many methods that have a special case that checks for any ender dragons and reacts properly to deal with these extra hitbox entities. Note that unlike vanilla and fabric, forge exposes these special cases with `IForgeEntity#isMultipartEntity`, `IForgeEntity#getParts`, and `PartEntity` so it's easy to hook into. So in vanilla/fabric checking if something is a multipart entity is done with `entity instanceof EnderDragonEntity` which means that making your own entities mimic this behaviour would require a whole bunch of mixins. 

> the terms "sub-hitboxes", "sub-entities" and "parts" are used interchangeably. 

### Methods with Special Behaviour

- `ServerLevel.EntityCallbacks#onTrackingStart` which adds entities to `ServerChunkCache#chunkMap#entityMap` (which maps all the entities to thier network sync id). When called for a multipart entity, it adds all the sub parts to `ServerLevel#dragonParts` which is then queried by `ServerLevel#getEntityOrPart`, along with the entity `LevelEntityGetter` that holds the normal entities from the `entityMap`, as called from `ServerboundInteractPacket#getTarget` (which is the method that `ServerGamePacketListenerImp#handleInteract` uses to handle left and right clicks on entities). So client sees you clicked entity number 7, sends that packet to the server which gets that entity from either the entityMap or the dragonParts map and deals with the interaction. Note that means that the part entities must be present on the client with the same netowrk id integer as on the server but since they are not directly added to the world, they can't use `Entity#getAddEntityPacket` like normal entities (it throws an `UnsupportedOperationException`). Instead, the part entities are created in `EnderDragon` constructor regardless of side and then in `EnderDragon#recreateFromPacket` (which is called on the client when the dragon is synced, like any other entity), the part entities are assigned sequential network numbers after the dragon's. In the entity constructor, the netowrk id is set to `ENTITY_COUNTER.incrementAndGet()` so when the parts are originally created on the server, they're made immediatly after the the dragon because it happens in the dragons constructor, so of course they have the next sequential ids. 
- `ServerLevel.EntityCallbacks#onTrackingEnd` removes all the part entities from `ServerLevel#dragonParts`
- `ServerLevel#removeEntity` which calls `ServerLevel#removeEntityComplete` loops through all parts of a multipart entity and calls `Entity#discard` to get rid of them as well. This calls `Entity#setRemoved` which calls `EntityInLevelCallback#onRemove` in either `PersistantEntitySectionManager` or `TransientEntitySectionManager` which calls `onTrackingEnd` in the respective `LevelCallback`, (the special case discussed above). 
- `EntityRenderDispatcher#renderHitboxes`, which draws the hitboxes around entities when enabled with F3+b, will get all the parts of a multipart entity and render thier hitbox outlines as well in a different colour. 
- The abstract `Level#getEntities` method (with no arguments) uses the `LevelEntityGetter` that does not include part entities. The varients of `Level#getEntities` that allow passing in a `Predicate<Entity>` or `EntityTypeTest<Entity, Entity>` call that method and for each element from the list that's in the bounding box, test it against the predicate argument to decide whether it should be added to the list to output. If it is a multipart entity (even if the parent entity fails the check), it also gets the list of parts and checks each against the predicate to add to the output list. 

> Forge's changes to these methods seem to work fully on 1.18.2. Although 1.16.5 had forge's `PartEntity` and associated `IForgeEntity` additions, not all those methods were changed to support it. For example `Level#getEntities` didn't so projectiles would not be able to hit your part without some mixins. 

> you probably want to override `Entity#isPickable` to return true on your part entity

